buildscript {
    ext {
        appName = "colony"
        gdxVersion = '1.13.5'
        gdxAiVersion = '1.8.2'
        jUnitVersion = '4.13.2'
        mockitoVersion = '5.16.1'
        artemisVersion = '2.3.0'
        checkstyleVersion = '10.25.0'
        slf4jVersion = '2.0.17'
        logbackVersion = '1.5.18'
        typesafeConfigVersion = '1.4.3'
    }

    repositories {
        mavenLocal()
        mavenCentral()
        google()
    }
} 

plugins {
    id 'jacoco'
    id 'com.diffplug.spotless' version '7.0.4' apply false
}


import org.gradle.process.ExecOperations
import org.gradle.process.ExecSpec

def getGitVersion() {
    def stdout = new ByteArrayOutputStream()
    def execOps = services.get(ExecOperations)
    execOps.exec { ExecSpec spec ->
        spec.commandLine 'git', 'describe', '--tags', '--abbrev=0'
        spec.standardOutput = stdout
        spec.ignoreExitValue = true
    }
    def ver = stdout.toString().trim()
    if (ver.isEmpty()) {
        ver = 'dev'
    }
    return ver
}

ext.applicationVersion = getGitVersion()

allprojects {
    apply plugin: 'java'
    apply plugin: 'eclipse'
    apply plugin: 'idea'
    apply plugin: 'checkstyle'
    apply plugin: 'com.diffplug.spotless'

    repositories {
        mavenLocal()
        mavenCentral()
        google()
    }

    java {
        toolchain {
            languageVersion = JavaLanguageVersion.of(21)
        }
    }

    tasks.withType(JavaCompile).configureEach {
        options.encoding = 'UTF-8'
    }

    checkstyle {
        toolVersion = checkstyleVersion
    }

    spotless {
        java {
            target 'src/**/*.java'
            leadingTabsToSpaces(4)
            trimTrailingWhitespace()
            endWithNewline()
        }
    }


    tasks.withType(Jar).configureEach {
        manifest.attributes('Implementation-Version': rootProject.applicationVersion)
    }
}

def coverageModules = ['core', 'client', 'server', 'tests']

subprojects { subproj ->
    if (coverageModules.contains(subproj.name)) {
        apply plugin: 'jacoco'

        jacoco {
            toolVersion = '0.8.13'
        }

        tasks.withType(Test).configureEach {
            finalizedBy 'jacocoTestReport'
        }

        tasks.withType(JacocoReport).configureEach {
            dependsOn 'test'
            reports {
                xml.required.set(true)
                html.required.set(true)
            }
            classDirectories.setFrom(
                files(classDirectories.files.collect {
                    fileTree(dir: it, exclude: ['**/generated/**', '**/*Launcher*'])
                })
            )
        }
    }
}

subprojects { proj ->
    if (proj.name != 'tests') {
        sourceSets {
            main.java.srcDirs = ['src/']
        }
    }
    dependencies {
        implementation "net.mostlyoriginal.artemis-odb:contrib-eventbus:2.5.0"
        implementation "org.slf4j:slf4j-api:$slf4jVersion"
    }
}

configure([project(':client'), project(':server'), project(':tests')]) {
    dependencies {
        implementation 'com.esotericsoftware:kryonet:2.22.0-RC1'
    }
}

project(':tests') {
    sourceSets {
        test.java.srcDirs = ['src/']
    }
}

tasks.register('codeCoverageReport', JacocoReport) {
    dependsOn subprojects.collect { it.tasks.withType(Test) }

    def coverageFiles = subprojects.collect { proj ->
        proj.tasks.withType(Test).collect {
            it.extensions.getByType(JacocoTaskExtension).destinationFile
        }
    }
    executionData.setFrom(files(coverageFiles))

    def sources = subprojects.collect { it.sourceSets.main.allSource.srcDirs }
    sourceDirectories.setFrom(files(sources))

    def classes = subprojects.collect { it.sourceSets.main.output }
    classDirectories.setFrom(files(classes).collect {
        fileTree(dir: it, exclude: ['**/generated/**', '**/*Launcher*'])
    })

    reports {
        xml.required.set(true)
        html.required.set(true)
    }
}
